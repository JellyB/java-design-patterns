动态代理的特点：
动态生成的代理类本身特点:
1. 包，如果所代理接口都是public的，那么它将被定义在顶层包（包路径为空），如果所代理接口中有非public的接口（因为接口不能被定义为protect或private,只能是public或package访问级别），那么将被定义在接口所在包，这样最大程度的保证动态代理类不会因为包管理问题导致不能成功被访问
2. 类修饰符，代理类有final 和 public ，可以被所有类访问，但是不能被继承
3. 类名，格式为"$ProxyN"，如果对同一组接口（包括接口的排列顺序相通）试图重复创建动态代理类，会返回之前已经创建好的代理类的类对象
4. 类继承关系，类Proxy是父类，这个规则适用于所有由Proxy创建的动态代理类，而且该类还实现了其所代理的一组接口，这也是为什么它能够被安全的类型转化到其所代理的某接口的原因
每个实例都会关联一个调用处理器对象，可以通过Proxy的静态方法`getInvocationHandler`去获取。在代理类实例上调用其代理的接口中所声明的方法时，这些方法最终都会由调用处理器的`invoke`方法执行。此外值得注意的是，代理类的根类`java.lang.Object`中有三个方法也同样会被分派到调用处理器的`invoke`方法执行，它们分别是`hashCode`、`equals`和`toString`可能原因有：
4.1 这些方法是`public`且非`final`的，能够被代理覆盖；
4.2 这些方法呈现出一个类的某些特殊属性，具有一定区分度，为了保证代理类与委托类对外的一致性，这三个方法也应该被分派到为拖类执行。
5. 被代理的接口特点：
5.1 不能有重复的接口，否则会编译错误；
5.2 这些接口对类装载器必须可见，否则无法链接它们，导致类定义失败
5.3 被代理的所有非public的接口必须在同一个包中，否则代理类生成会失败
5.4 接口数不能超过65536 jvm 规定
6. 异常抛出，调用处理器接口上理论上可以抛出任何类型的异常。但是我们必须要知道的是，当子类覆盖父类或实现父接口的方法时，抛出的异常必须在源方法支持的异常列表内，除非父接口中的方法支持抛出`Throwable`异常。如果在`invoke`方法中的确产生了接口方法声明中不支持的异常，会抛出
`UndeclaredThrowableExeption`异常，是`RuntimeException`